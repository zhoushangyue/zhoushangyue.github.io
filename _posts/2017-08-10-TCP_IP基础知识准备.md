---
layout: post
title:  "TCP/IP基础知识准备"
date:   2017-08-10
excerpt: "个人整理网络知识的一些要点，面试备用。"
tag:
- tcp/ip
comments: true
---

第1章

1，IP地址的格式与分类

A类地址：首位bit为0，第一字节为网络号，剩下三字节为主机号，地址范围：0.0.0.0~127.255.255.255

B类地址：前两位bit为10，前两个字节为网络号，后两个字节为主机号，地址范围：128.0.0.0~191.255.255.255

C类地址：前三位bit为110，前三个字节为网络号，后一个字节为主机号，地址范围：192.0.0.0~223.255.255.255

D类地址：前四位bit为1110，后28位bit为多播组号，地址范围：224.0.0.0~239.255.255.255

E类地址：前五位bit为11110，后27为bit为备用，地址范围：240.0.0.0~255.255.255.255


第3章

1，子网划分

子网编址是指将主机号再分成一个子网号和一个主机号，这么做的原因是A类和B类地址为主机号分配了太多空间。将一个B类网址分为30个子网相比使用30个C类网址来说缩小了Internet路由表的规模。

2，子网掩码

通过IP的前几位可以确定IP数据报的目的是否哪一类网络，再通过子网掩码就可以进一步判断出网络号与主机号之间的分界线，主机就可以确定IP数据报的目的是本子网上的主机，本网络中其它子网的主机还是其它网络上的主机。

3，查询网络接口信息命令ifconfig(-a)和netstat(-i,-n)。

ifconfig 会显示网络接口信息：配置参数，IP地址，子网掩码，广播地址。

netstat提供系统上的接口信息，-i直接打印出接口信息，-n参数打印出IP地址而不是主机名字。这个命令可以打印出每个借口的MTU、输入/输出分组数、输入/输出错误、冲突以及当前的输出队列长度。


第4章

1，ARP地址解析过程：

每个主机上建立自己的ARP高速缓存列表来表示IP地址和MAC地址之间的映射关系；当源主机发送数据时，首先检查ARP高速缓存列表中有没有目的IP对应的MAC地址，如果没有找到则发送一份ARP请求给本网段的每个主机，告知源IP的MAC地址并询问目的IP对应的MAC地址；当主机收到ARP请求时，检查需要查询的IP是否是本主机IP，不是则丢弃，是则将数据包源IP与源MAC地址的映射关系存入自己的ARP列表中，并将自身的MAC地址写入ARP响应数据包中发送给源主机。


第6章

1，ICMP报文的作用

IP层的一个重要组成部分，传递差错报文以及其它需要注意的信息。分为差错报文和查询报文。不同类型由类型字段和代码字段共同决定。类型：0回显应答，3目的不可达，5重定向，8请求回显，11超时，13，时间戳请求。。。

2，不会导致产生ICMP报文的情况

ICMP差错报文；目的地址是广播地址或者多播地址的IP数据报；作为链路层广播的数据报；不是IP分片的第一片；源地址不是单个主机的数据报：既源地址不能为零地址、回环地址、广播地址和多播地址。

3，ping程序

发送一份ICMP回显请求报文给主机，并等待返回ICMP回显应答。来确认两台机器是否连通。

4，traceroute工作原理

traceroute首先发送TTL字段为1的IP数据报给目的主机。处理这份数据报的路由器给TTL字段减1，TTL变为0，路由器将该数据报丢掉并给发回一份超时ICMP报文。这样就得到了第一个路由器的IP地址，然后再发送一个TTL字段为2的数据报，得到第二个路由器地址。。。继续这个过程直到该数据报到达目的主机。
由于发送的UDP数据报是选择一个不可能的值作为其目的端口，当该数据报到达时，目的主机UDP会产生一份“端口不可达”错误的ICMP报文。当traceroute收到该报文时就知道目的地已经到达了。


第10章

1，OSPF和RIP的不同点在于OSPF直接使用IP，RIP使用UDP。

RIP协议：使用UDP，底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。

OSPF协议：使用IP，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。
除此之外OSPF还有以下优点：

(1)OSPF可以对每个IP服务类型计算各自的路由集。这意味着对于任何目的，可以有多个路由表表项，每个表项对应着一个IP服务类型；

(2)给每个接口指派一个无维数的费用。可以通过吞吐率、往返时间、可靠性或其他性能来进行指派一个单独的费用；

(3)当对同一个目的地址存在着多个相同费用的路由时，OSPF在这些路由上平均分配流量，称之为流量平衡；

(4)OSPF支持子网：子网掩码与每个通告路由相连。

。。。

2，BGP：边界网关协议，使用TCP，允许自治系统管理员制定策略，并通过配置文件将策略指定给BGP。也是距离向量协议，但与RIP不同的是，BGP列举了到每个目的地址的路由。（自治系统到达目的地址的序列号）


第13章

1，IGMP作用

用于支持主机和路由器进行多播管理。它让一个物理网络上的所有系统知道主机当前所在的多播组。IP层的一部分。


第14章

1，DNS用TCP还是UDP

DNS主要使用UDP53端口，无论名字解析器还是名字服务器都必须自己处理超时和重传。

当DNS服务器进行域间传输时用TCP53端口

当名字解析器发送一个查询请求，并且返回相应中的TC比特被置为1时，意味着响应长度超过了512字节，而仅返回前512字节。在遇到这种情况时，名字解析器通常使用TCP重发原来的查询请求，它将允许返回的响应超过512字节。

2，UDP的长度限制

Internet标准的链路层MTU被限制在576字节，除去IP报头固定的20字节，在除去UDP报头8字节，UDP数据部分最长应为546字节，超过这个长度会产生IP分片。而以报文为单位传输的UDP数据报是不可靠传输，如果在IP层产生分片，任何一片数据的缺失都会造成整个报文的不可达，加重其不可靠性。因此实际应用中常常将UDP报文数据部分限制在512字节。

3，UDP常见的应用层协议

TFTP：简单文件传送协议，端口为(69)，由于TFTP不提供用户名和口令，常常被高手用来回去系统的用户口令信息，安全性措施就是限制TFTP的访问权限。

BOOTP：服务器端口(67)，客户端端口(68)，引导程序协议，用于无盘系统进行系统引导（获取自身IP地址等）。

DNS：域名解析，53端口。

3，


第17章

1，TCP与UDP的区别

TCP是面向连接的协议，在传输数据包之前，先要三次握手建立会话连接，会话结束时要四次挥手结束该连接。而UDP是无连接的。TCP本身具有超时重传机制，可以实现可靠传输，UDP不保证传输可靠性。UDP传输速度快，适合局域网内传输少量数据。TCP传输速度较慢，适合远距离传输大量数据。TCP是面向字节流的传输，UDP是面向报文的传输。

2，TCP通过什么方式保证可靠性

应用数据被分割成TCP认为最适合发送的数据块。应用程序产生的数据报长度将保持不变；

当TCP发出一个段后，启动定时器，等待目的端确认收到这个报文段。如果不能及时收到确认，将重发该报文；

当TCP一端收到另一端的数据，则放送一个确认(推迟几分之一秒)；

TCP保持首部和数据的检验和。检测数据在传输过程中的任何变化。如果收到段的检验和有错误，则丢弃并不确认接收；

TCP将对收到的数据重新排序，将收到的数据以正确的顺序交给应用层；

TCP还能提供流量控制，TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。

第18章

1，TCP连接的建立

请求段发送一个syn段指明客户打算连接的服务器的端口，以及初始序号；

服务器端发回包含服务器的初始序号的syn报文段作为应答。同时，将确认序号ack设置为客户的ISN加1以对服务器的SYN报文段进行确认。

客户再将将确认序号ack设置为服务器的ISN加1以对服务器的syn报文段进行确认。

2，TCP连接的结束

首先一方发送fin数据包；

另一方收到fin后发送该fin的ack。

接收方发送一个fin数据包给发起方；

发起方接收fin数据包并返回fin的ack。

3，TCP状态图

![image](http://img.my.csdn.net/uploads/201209/24/1348471799_4164.jpg)

4，TIME_WAIT状态

TCP协议在关闭连接的四次握手之后，为了应对最后一个ack丢失的情况，Client（即主动关闭的一方）需要维持time_wait状态并停留2MSL的时间。

危害：Linux分给一个用户的文件句柄是有限的，如果系统中存在大量的time_wait状态，一但达到句柄数上限，新的请求法被处理。大量该状态连接占用资源影响性能

解决方式：在/etc/sysctl.conf文件中开启net.ipv4.tcp_tw_reuse重用和net.ipv4.tcp_tw_recycle快速回收

5，平静时间概念

对于来自某个连接的较早替身的迟到报文段，2MSL等待可以防止将它解释成新连接的一部分，这是主机处于正常工作状态时才有效的。

如果使用处于2MLS等待端口的主机出现故障，且再MSL秒内重启，并立即使用故障前处于2MSL秒内的的插口对来建立新连接，则迟到报文仍会干扰新的连接。

为了防止出现以上情况，固定TCP重启后MSL秒内不能建立任何连接，即平静时间

第20章

1，TCP滑动窗口机制

TCP头部里有一个窗口大小字段，用于接收端告诉发送端自己还有多少缓冲区可以接收数据，于是发送端就可以根据这个剩余空间来发送数据，而不会导致发送端接收不过来

接收端在给发送端回ACK中会汇报自己的剩余缓冲区大小，而发送方会根据这个窗口来控制下一次发送数据的大小：

当窗口左边沿向右边沿靠近，为窗口合拢。这种现象多发生在数据被发送和确认时。

当窗口右边沿向右方向移动时，为窗口张开。这现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时。

2，Zero Window：

如果接收端处理缓慢，导致发送方的滑动窗口变为0了，怎么办？—— 这时发送端就不发数据了，但发送端会发ZWP（即Zero Window Probe技术）的包给接收方，让接收方回ack更新Window尺寸，一般这个值会设置成3次，每次大约30-60秒。如果3次过后还是0的话，有的TCP实现就会发RST把连接断了。

3，Silly Window

Syndrome：即“糊涂窗口综合症”，当发送端产生数据很慢、或接收端处理数据很慢，导致每次只发送几个字节，也就是我们常说的小数据包 —— 当大量的小数据包在网络中传输，会大大降低网络容量利用率。比如一个20字节的TCP首部+20字节的IP首部+1个字节的数据组成的TCP数据报，有效传输通道利用率只有将近1/40。

为了避免发送大量的小数据包，TCP提供了Nagle算法，Nagle算法默认是打开的，可以在Socket设置TCP_NODELAY选项来关闭这个算法。

4，TCP拥塞控制

我们知道TCP通过一个定时器（timer）采样了RTT并计算RTO，但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，然而重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这就导致了恶性循环，最终形成“网络风暴” —— TCP的拥塞控制机制就是用于应对这种情况。

首先需要了解一个概念，为了在发送端调节所要发送的数据量，定义了一个“拥塞窗口”（Congestion Window），在发送数据时，将拥塞窗口的大小与接收端ack的窗口大小做比较，取较小者作为发送数据量的上限。

拥塞控制主要是四个算法：

**慢启动**：意思是刚刚加入网络的连接，一点一点地提速，不要一上来就把路占满。


- 连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。

- 每当收到一个ACK，cwnd++; 呈线性上升
- 每当过了一个RTT，cwnd = cwnd*2;呈指数上升
- 阈值ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”

**拥塞避免**：当拥塞窗口 cwnd 达到一个阈值时，窗口大小不再呈指数上升，而是以线性上升，避免增长过快导致网络拥塞。

- 每当收到一个ACK，cwnd = cwnd + 1/cwnd

- 每当过了一个RTT，cwnd = cwnd + 1

**拥塞发生**：当发生丢包进行数据包重传时，表示网络已经拥塞。分两种情况进行处理：

- 等到RTO超时，重传数据包

   -   sshthresh = min(cwnd,接收方通告窗口) /2

   -   cwnd 重置为 1

   -   进入慢启动过程

- 在收到3个duplicate ACK时就开启重传，而不用等到RTO超时

   -  sshthresh = cwnd = cwnd /2

   -  进入快速恢复算法——Fast Recovery

**快速恢复**：至少收到了3个Duplicated Acks，说明网络也不那么糟糕，可以快速恢复。

- cwnd = sshthresh + 3 * MSS （3的意思是确认有3个数据包被收到了）
- 
- 重传Duplicated ACKs指定的数据包
- 如果再收到 duplicated Acks，那么cwnd = cwnd +1
- 如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。

第22章

1，TCP坚持定时器

当一个TCP连接发送端的窗口为0时，需要靠接收端的ACK来通知何时打开窗口。但ACK的传输并不可靠，于是发送方使用一个坚持定时器来周期性地像接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文称为窗口探查

第23章

1，TCP的保活定时器

用于在双方建立连接但长时间不交换任何信息的情况下，通知服务器客户主机是否崩溃。

第26~30章

常见的TCP应用：

远程登陆协议：Telnet和Rlogin

文件传输协议：FTP

邮件协议：SMTP和POP3

超文本传输协议：HTTP
